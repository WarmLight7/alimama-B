#pragma once

#include <memory>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>

#include "concurent_queue.h"
#include "helloworld.grpc.pb.h"
#include "csv.h"

using alimama::proto::Request;
using alimama::proto::Response;
using csv::CSVReader;

struct TestCasePair{
    bool repeat;
    Request req;
    Response response;
};

std::vector<uint64_t> parseUint64List(const std::string& s) {
    std::vector<uint64_t> result;
    std::istringstream ss(s);
    std::string item;
    while (std::getline(ss, item, ',')) {
        result.push_back(std::stoull(item));
    }
    return result;
}

std::vector<float> parseFloatList(const std::string& s) {
    std::vector<float> result;
    std::istringstream ss(s);
    std::string item;
    while (std::getline(ss, item, ',')) {
        result.push_back(std::stof(item));
    }
    return result;
}



class TestCaseReader{
private:
    ConcurrentQueue<TestCasePair> testcase;
    std::vector<std::thread> threads;
    std::atomic<bool> enable;
    std::string filename;

    CSVReader<6> reader:

    reloadfile() {
        CSVReader<6, trim_chars<' '>, no_quote_escape<'\t'>> reader(this->filename);
        reader.read_header(ignore_no_column, "keywords", "context_vector", "hour", "topn", "adgroup_ids", "prices");
        this->reader = reader;
    }

public:
    TestCaseReader(std::string filename, int32_t capacity):threads(1) {
        this->filename = filename;
    }
    TestCaseReader(const TestCaseReader&) = delete;
    TestCaseReader(TestCaseReader&&) = delete;
    TestCaseReader& operator=(const TestCaseReader&) = delete;
    TestCaseReader& operator=(TestCaseReader&&) = delete;
    ~TestCaseReader() {
    }
    void start() {
        for (size_t i = 0; i < this->threads.size(); ++i) {
            threads[i] = std::thread([&]() {
                std::string keywords, context_vector;
                uint64_t hour, topn;
                std::string adgroup_ids, prices;
                bool reapeat = false;
                while(true) {
                    auto ok = this->reader.read_row(keywords, context_vector, hour, topn, adgroup_ids, prices);
                    if (!ok) {
                        reapeat = true;
                        this->reloadfile();
                    }

                    Request request;
                    Response response;
                    for (auto keyword : parseUint64List(keywords)) {
                        request.add_keywords(keyword);
                    }
                    for (auto vec : parseFloatList(context_vector)) {
                        request.add_context_vector(vec);
                    }
                    request.set_hour(hour);
                    request.set_topn(topn);
                    for (auto id : parseUint64List(adgroup_ids)) {
                        response.add_adgroup_ids(id);
                    }
                    for (auto price : parseUint64List(prices)) {
                        response.add_prices(price);
                    }
                    TestCasePair pair_data{
                        reapeat,
                        request,
                        response
                    };
                    if (!this->testcase.push(pair_data)) {
                        break;
                    }
                }
            });
        }
    }

    void stop() {
        this->enable.store(false);
        this->testcase.close();
        for (size_t i = 0; i < this->threads.size(); ++i) {
            this->threads[i].join();
        }
    }

    void pop(TestCasePair& pair) {
        this->testcase.wait_and_pop(pair);
    }
};
